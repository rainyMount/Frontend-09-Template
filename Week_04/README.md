## 字符串分析算法
### 一、总论
1. 字典树--大量高重复字符串的存储与分析
2. KMP--在长字符串找模式
3. Wildcard--带通配符的字符串模式
4. 正则--字符串通用模式匹配
5. 状态机--通用的字符串分析
6. LL、LR--字符串多层级结构分析

## 二、字典树
1. String.fromCharCode(): 将 Unicode 编码转为一个字符
2. String.charCodeAt(index): 返回字符串第index+1个字符的 Unicode 编码
3. new Object() 与 Object.create(null) 的区别：
    + Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。使用 new Object() 和对象字面量这种形式创建的空对象，会继承Object 的方法和属性


### 三、KMP:模式匹配算法
在字符串模式匹配时，包含 source 原串与 pattern 模式串。因为 pattern 本身会有重复的部分，如果每一次都从头开始匹配，会导致很多重复匹配过程。因此利用待 pattern 的自重复，创建一个与模式串长度相同的数组，在里面分别填上到此已经有几个字母重复。当做原串与模式串对比时，发现有不匹配的字符，暂时不回退到最开始的状态，先看前面有几位重复的，把模式串的位置跳到重复的位置。

通过以上分析，在实现 KMP 算法时，首先需要创建一个跳转表格，再拿原串跟模式串做对比：

1. 求跳转表格；
2. 实现匹配算法。


### 四、wildcard
在字符串中加入了 * ? 两种通配符。例如 ab*cd*abc*a?d
1. 对于 * 来说，模式串中的最后一个 * 是可以匹配任意字符的，所以它可以尽量的多匹配，除最后一个之外的其他星号，要尽可能的少匹配
2. ab*cd*abc*a?d 可以分为三个大类 a. 开头的 ab，只匹配开头的字符 b. 结尾的 a?d，只匹配结尾的字符 c. 中间的 * + 字符 作为一组的组合
因此可以认为一个 Wildcard 就是若干个 KMP，但由于还有 ?，实现带问号的 KMP 相对来说较复杂，可以使用正则代替。但是整个字符都使用正则来匹配性能消耗会很大，因此需要通过逐段的转化成 exec 来处理正则。
